generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex", "postgresqlExtensions"]
  output          = "../client"
  binaryTargets   = ["native", "debian-openssl-1.1.x", "linux-musl-openssl-3.0.x"]
}

generator pothos {
  provider     = "prisma-pothos-types"
  clientOutput = "@klicker-uzh/prisma"
  output       = "../client/pothos.ts"
}

generator json {
  provider = "prisma-json-types-generator"
}

datasource db {
  provider          = "postgres"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum PublicationStatus {
  DRAFT
  // REVIEW
  PUBLISHED
}

// ----- USER ACCOUNTS -----
// #region
enum UserRole {
  PARTICIPANT
  USER
  ADMIN
}

model Account {
  id String @id @default(uuid()) @db.Uuid

  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Uuid

  @@unique([provider, providerAccountId])
}

model Session {
  id String @id @default(uuid()) @db.Uuid

  sessionToken String   @unique
  expires      DateTime

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Uuid
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserLoginScope {
  ACCOUNT_OWNER
  FULL_ACCESS
  SESSION_EXEC
  READ_ONLY
}

model UserLogin {
  id String @id @default(uuid()) @db.Uuid

  name        String         @default("-")
  password    String
  scope       UserLoginScope @default(READ_ONLY)
  lastLoginAt DateTime?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Uuid
}

enum Locale {
  en
  de
}

model User {
  id String @id @default(uuid()) @db.Uuid

  originalId String? @unique

  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?

  shortname           String    @unique
  lastLoginAt         DateTime?
  deletionToken       String?
  deletionRequestedAt DateTime?
  loginToken          String?
  loginTokenExpiresAt DateTime?

  locale Locale @default(en)

  role UserRole @default(USER)

  catalystInstitutional Boolean @default(false)
  catalystIndividual    Boolean @default(false)
  catalystTier          String?

  logins            UserLogin[]
  session           Session[]
  accounts          Account[]
  courses           Course[]
  questions         Element[]
  mediaFiles        MediaFile[]
  tags              Tag[]
  questionInstances QuestionInstance[]
  sessions          LiveSession[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]
  groupActivities   GroupActivity[]
  elementInstances  ElementInstance[]
  practiceQuizzes   PracticeQuiz[]

  firstLogin Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- MEDIA LIBRARY -----
// #region
model MediaFile {
  id String @id @default(uuid()) @db.Uuid

  href        String  @unique
  name        String
  type        String
  description String?

  originalId String? @unique

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- TAGS AND SKILLS -----
// #region
model Tag {
  id   Int    @id @default(autoincrement())
  name String

  order Int @default(0)

  originalId String? @unique

  questions Element[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ownerId, name])
}

// #endregion

// ----- ELEMENTS -----
// #region
enum ElementOrderType {
  SEQUENTIAL
  SHUFFLED
  LAST_RESPONSE
}

enum ElementType {
  // TODO: remove old types, to be migrated to new ones
  SC
  MC
  KPRIM
  FREE_TEXT
  NUMERICAL

  // new types
  CONTENT
  FLASHCARD
  QUESTION_SC
  QUESTION_MC
  QUESTION_KPRIM
  QUESTION_FREE_TEXT
  QUESTION_NUMERICAL
}

// TODO: remove once moved to options
enum ElementDisplayMode {
  LIST
  GRID
}

model Element {
  id Int @id @default(autoincrement())

  // TODO: implement the logic for this
  version Int @default(1) // used to track question versions, incremented on each update

  originalId String? @unique

  isArchived Boolean @default(false)
  isDeleted  Boolean @default(false)

  name        String
  content     String // markdown content
  explanation String? // markdown content

  pointsMultiplier Int @default(1) // currently only relevant for FLASHCARD and QUESTION types

  // TODO: the three properties below are only relevant for questions and can be moved to options Json
  displayMode        ElementDisplayMode @default(LIST)
  hasSampleSolution  Boolean            @default(false)
  hasAnswerFeedbacks Boolean            @default(false)

  /// [PrismaElementOptions]
  options Json

  type ElementType

  tags Tag[]

  // TODO: as we renamed Question to Element, it will need to have instances and elementInstances in parallel for a while. once we migrated all question instances and activities to elements, we can remove instances with a migration.
  instances        QuestionInstance[]
  elementInstances ElementInstance[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// TODO: elements are only supported for the new PRACTICE_QUIZ type in the first iteration. add the other types here when working on them.
enum ElementInstanceType {
  PRACTICE_QUIZ
}

model ElementInstance {
  id Int @id @default(autoincrement())

  originalId String? @unique

  type        ElementInstanceType
  elementType ElementType
  order       Int

  // TODO: moved to options Json
  // resetTimeDays    Int?
  // pointsMultiplier Int                      @default(1)
  // TODO: moved to results Json
  // participants    Int                      @default(0)

  /// [PrismaElementInstanceOptions]
  options Json // contains element type specific settings (resetTimeDays for LE instances, pointsMultiplier where relevant)

  /// [PrismaElementData]
  elementData Json // contains a copy of relevant element data

  /// [PrismaElementInstanceResults]
  results Json // contains the collection of gathered results

  responses       QuestionResponse[]
  detailResponses QuestionResponseDetail[]

  bookmarkedBy Participation[]

  element        Element?     @relation(fields: [elementId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  elementId      Int?
  elementStack   ElementStack @relation(fields: [elementStackId], references: [id])
  elementStackId Int
  owner          User         @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId        String       @db.Uuid
  course         Course?      @relation(fields: [courseId], references: [id])
  courseId       String?      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, elementStackId, order])
}

enum ElementStackType {
  LIVE_QUIZ
  PRACTICE_QUIZ
  MICROLEARNING
  GROUP_ACTIVITY
}

model ElementStack {
  id Int @id @default(autoincrement())

  // element stacks need to have an originalId to enable migration from v2 session blocks
  originalId String? @unique

  type  ElementStackType
  order Int?

  // TODO: we needed the two below for the stacked learning elements (Excel) as a top-level title and description. maybe we could drop them if we add a content element before the questions and the name of the content element is the top-level title, though it would be the same "size" as the other titles. however, this would add a lot of content elements to the question pool that cannot "stand on their own", and we might want to use content elements primarily for short snippets of content to repeat, not for some intro text to an element stack. this would mean we keep displayName and description here and as optional fields.
  displayName String?
  description String?

  /// [PrismaElementStackOptions]
  options Json

  elements     ElementInstance[]
  bookmarkedBy Participation[]

  practiceQuiz   PracticeQuiz? @relation(fields: [practiceQuizId], references: [id])
  practiceQuizId String?       @db.Uuid

  @@unique([type, practiceQuizId, order])
}

// #endregion

// ----- PRACTICE QUIZZES -----
// #region
model PracticeQuiz {
  id String @id @default(uuid()) @db.Uuid

  name             String
  displayName      String
  description      String?
  pointsMultiplier Int               @default(1)
  resetTimeDays    Int               @default(6)
  orderType        ElementOrderType  @default(SEQUENTIAL)
  status           PublicationStatus @default(DRAFT)

  stacks ElementStack[]

  owner    User    @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String  @db.Uuid
  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- QUESTION POOL (LEGACY) -----
// #region
enum QuestionInstanceType {
  UNSET
  SESSION
  MICRO_SESSION
  LEARNING_ELEMENT
  GROUP_ACTIVITY
}

model QuestionInstance {
  id Int @id @default(autoincrement())

  originalId String? @unique

  type  QuestionInstanceType?
  order Int?

  participants     Int                      @default(0)
  pointsMultiplier Int                      @default(1)
  responses        QuestionResponse[]
  detailResponses  QuestionResponseDetail[]
  resetTimeDays    Int?

  /// [PrismaElementData]
  questionData Json

  /// [PrismaQuestionResults]
  results Json

  sessionBlock    SessionBlock?  @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId  Int?
  stackElement    StackElement?  @relation(fields: [stackElementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  stackElementId  Int?           @unique
  microSession    MicroSession?  @relation(fields: [microSessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  microSessionId  String?        @db.Uuid
  groupActivity   GroupActivity? @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String?        @db.Uuid

  bookmarkedBy Participation[]

  question   Element? @relation(fields: [questionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  questionId Int?
  owner      User     @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String   @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, sessionBlockId, order])
  @@unique([type, stackElementId, order])
  @@unique([type, microSessionId, order])
  @@unique([type, groupActivityId, order])
}

enum QuestionStackType {
  LEARNING_ELEMENT
  MICRO_SESSION
  LIVE_SESSION
  GROUP_ACTIVITY
}

model QuestionStack {
  id Int @id @default(autoincrement())

  type        QuestionStackType
  displayName String?
  description String?
  order       Int?

  elements StackElement[]

  learningElement   LearningElement? @relation(fields: [learningElementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  learningElementId String?          @db.Uuid
  groupActivity     GroupActivity?

  bookmarkedBy Participation[]

  @@unique([type, learningElementId, order])
}

model StackElement {
  id Int @id @default(autoincrement())

  order Int?

  stack   QuestionStack @relation(fields: [stackId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  stackId Int

  mdContent String?

  questionInstance QuestionInstance?
}

// #endregion

// ----- COURSES -----
// #region
model Course {
  id String @id @default(uuid()) @db.Uuid

  isArchived Boolean @default(false)

  pinCode Int @unique

  name                  String
  displayName           String
  description           String?
  color                 String?   @default("#eaa07d")
  startDate             DateTime
  endDate               DateTime
  groupDeadlineDate     DateTime?
  notificationEmail     String?
  isGamificationEnabled Boolean   @default(true)

  sessions          LiveSession[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]
  elementInstances  ElementInstance[]
  practiceQuizzes   PracticeQuiz[]
  groupActivities   GroupActivity[]
  leaderboard       LeaderboardEntry[]
  awards            AwardEntry[]
  classAchievements ClassAchievementInstance[]
  achievements      Achievement[]
  titles            Title[]
  participations    Participation[]
  subscriptions     PushSubscription[]
  participantGroups ParticipantGroup[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- SESSIONS -----
// #region
enum SessionBlockStatus {
  SCHEDULED
  ACTIVE
  EXECUTED
}

model SessionBlock {
  id Int @id @default(autoincrement())

  originalId String? @unique

  order  Int?
  status SessionBlockStatus @default(SCHEDULED)

  expiresAt       DateTime?
  timeLimit       Int?
  randomSelection Int?

  execution Int @default(0)

  instances   QuestionInstance[]
  leaderboard LeaderboardEntry[]

  activeInSession LiveSession[] @relation(name: "ActiveSessionBlock")

  session   LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, order])
}

enum SessionStatus {
  PREPARED
  SCHEDULED
  RUNNING
  COMPLETED
}

enum AccessMode {
  PUBLIC
  RESTRICTED
}

model LiveSession {
  id String @id @default(uuid()) @db.Uuid

  originalId                 String? @unique
  isLiveQAEnabled            Boolean @default(false)
  isConfusionFeedbackEnabled Boolean @default(true)
  isModerationEnabled        Boolean @default(true)
  isGamificationEnabled      Boolean @default(false)

  namespace        String    @default(uuid()) @db.Uuid
  pinCode          Int?
  name             String
  displayName      String
  description      String?
  startedAt        DateTime?
  finishedAt       DateTime?
  linkTo           String?
  pointsMultiplier Int       @default(1)

  accessMode AccessMode    @default(PUBLIC)
  status     SessionStatus @default(PREPARED)

  activeBlock   SessionBlock? @relation(name: "ActiveSessionBlock", fields: [activeBlockId], references: [id])
  activeBlockId Int?

  blocks      SessionBlock[]
  leaderboard LeaderboardEntry[]

  feedbacks Feedback[]

  confusionFeedbacks ConfusionTimestep[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- LEARNING ELEMENTS -----
// #region
enum OrderType {
  SEQUENTIAL
  SHUFFLED
  LAST_RESPONSE
}

enum LearningElementStatus {
  DRAFT
  PUBLISHED
}

model LearningElement {
  id String @id @default(uuid()) @db.Uuid

  name             String
  displayName      String
  description      String?
  pointsMultiplier Int                   @default(1)
  resetTimeDays    Int                   @default(6)
  orderType        OrderType             @default(SEQUENTIAL)
  status           LearningElementStatus @default(DRAFT)

  stacks QuestionStack[]

  owner    User    @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String  @db.Uuid
  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- MICROLEARNING -----
// #region
enum MicroSessionStatus {
  DRAFT
  PUBLISHED
}

model MicroSession {
  id String @id @default(uuid()) @db.Uuid

  name             String
  displayName      String
  pointsMultiplier Int                @default(1)
  description      String?
  status           MicroSessionStatus @default(DRAFT)

  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  arePushNotificationsSent Boolean @default(false)

  instances QuestionInstance[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  // TODO: why is course optional?
  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- GROUP ACTIVITIES -----
// #region
enum ParameterType {
  NUMBER
  STRING
}

model GroupActivityParameter {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type    ParameterType
  options String[]
  unit    String?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  @@unique([groupActivityId, name])
}

model GroupActivityClue {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type  ParameterType
  value String
  unit  String?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  @@unique([groupActivityId, name])
}

model GroupActivityClueInstance {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type  ParameterType
  value String
  unit  String?

  assignments             GroupActivityClueAssignment[]
  groupActivityInstance   GroupActivityInstance         @relation(fields: [groupActivityInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityInstanceId Int

  @@unique([groupActivityInstanceId, name])
}

enum GroupActivityStatus {
  DRAFT
  PUBLISHED
}

model GroupActivity {
  id String @id @default(uuid()) @db.Uuid

  name        String
  displayName String
  status      GroupActivityStatus @default(DRAFT)

  description      String?
  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  questionStack   QuestionStack? @relation(fields: [questionStackId], references: [id])
  questionStackId Int?           @unique

  parameters        GroupActivityParameter[]
  clues             GroupActivityClue[]
  instances         QuestionInstance[]
  activityInstances GroupActivityInstance[]

  owner    User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GroupActivityClueAssignment {
  id Int @id @default(autoincrement())

  groupActivityClueInstance   GroupActivityClueInstance @relation(fields: [groupActivityClueInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityClueInstanceId Int
  groupActivityInstance       GroupActivityInstance     @relation(fields: [groupActivityInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityInstanceId     Int
  participant                 Participant               @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId               String                    @db.Uuid
}

model GroupActivityInstance {
  id Int @id @default(autoincrement())

  clues                  GroupActivityClueInstance[]
  clueInstanceAssignment GroupActivityClueAssignment[]

  decisions            Json?
  decisionsSubmittedAt DateTime?
  results              Json?
  resultsComputedAt    DateTime?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  group   ParticipantGroup @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupId String           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupActivityId, groupId])
}

// #endregion

// ----- LIVE Q&A -----
// #region
model Feedback {
  id Int @id @default(autoincrement())

  isPublished Boolean @default(false)
  isPinned    Boolean @default(false)
  isResolved  Boolean @default(false)

  content String
  votes   Int    @default(0)

  responses FeedbackResponse[]

  resolvedAt DateTime?

  session   LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String      @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String?      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FeedbackResponse {
  id Int @id @default(autoincrement())

  content           String
  positiveReactions Int    @default(0)
  negativeReactions Int    @default(0)

  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  feedbackId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ConfusionTimestep {
  id Int @id @default(autoincrement())

  difficulty Int
  speed      Int

  session   LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String      @db.Uuid

  createdAt DateTime @default(now())
}

// #endregion

// ----- PARTICIPANTS -----
// #region
model ParticipantAccount {
  id String @id @default(uuid()) @db.Uuid

  ssoId String @unique

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())
}

model Participant {
  id String @id @default(uuid()) @db.Uuid

  email        String? @unique
  isEmailValid Boolean @default(false)
  username     String  @unique
  password     String
  avatar       String?
  xp           Int     @default(0)

  /// [PrismaAvatarSettings]
  avatarSettings Json?

  isActive        Boolean @default(true)
  isProfilePublic Boolean @default(true)
  isSSOAccount    Boolean @default(false)

  lastLoginAt DateTime?

  locale Locale @default(en)

  participantGroups       ParticipantGroup[]
  accounts                ParticipantAccount[]
  participations          Participation[]
  questionResponses       QuestionResponse[]
  detailQuestionResponses QuestionResponseDetail[]
  feedbacks               Feedback[]
  leaderboards            LeaderboardEntry[]
  subscriptions           PushSubscription[]
  clueAssignments         GroupActivityClueAssignment[]
  awards                  AwardEntry[]
  achievements            ParticipantAchievementInstance[]
  titles                  Title[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ParticipantGroup {
  id String @id @default(uuid()) @db.Uuid

  name String
  code Int

  groupActivityScore Float @default(0)
  averageMemberScore Float @default(0)

  participants    Participant[]
  groupActivities GroupActivityInstance[]
  awards          AwardEntry[]
  achievements    GroupAchievementInstance[]

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: SetNull)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, code])
}

model Participation {
  id Int @id @default(autoincrement())

  // enable participants to disable their participation
  // keeps the collected points but removes them from all views
  isActive Boolean @default(false)

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  courseLeaderboard   LeaderboardEntry? @relation(fields: [courseLeaderboardId], references: [id], onDelete: SetNull, onUpdate: SetNull)
  courseLeaderboardId Int?              @unique

  sessionLeaderboards LeaderboardEntry[] @relation("SessionLeaderboards")

  responses               QuestionResponse[]
  detailResponses         QuestionResponseDetail[]
  subscriptions           PushSubscription[]
  completedMicroSessions  String[]
  bookmarkedQuestions     QuestionInstance[]
  bookmarkedStacks        QuestionStack[]
  bookmarkedElements      ElementInstance[]
  bookmarkedElementStacks ElementStack[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, participantId])
}

enum LeaderboardType {
  SESSION_BLOCK
  SESSION
  COURSE
}

model LeaderboardEntry {
  id Int @id @default(autoincrement())

  type LeaderboardType

  score Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation Participation?

  sessionParticipation   Participation? @relation("SessionLeaderboards", fields: [sessionParticipationId], references: [id])
  sessionParticipationId Int?

  sessionBlock   SessionBlock? @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId Int?

  session   LiveSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String?      @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  @@unique([type, participantId, sessionBlockId])
  @@unique([type, participantId, sessionId])
  @@unique([type, participantId, courseId])
}

// #endregion

// ----- RESPONSE TRACKING -----
// #region
model QuestionResponse {
  id Int @id @default(autoincrement())

  trialsCount        Int       @default(0)
  totalScore         Float     @default(0)
  totalPointsAwarded Float?    @default(0)
  totalXpAwarded     Float     @default(0)
  lastAwardedAt      DateTime?
  lastXpAwardedAt    DateTime?

  /// [PrismaQuestionResponse]
  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  // TODO: for now, a response can be associated with either a questionInstance or elementInstance, but in the future only elementInstance will remain and be required
  questionInstance   QuestionInstance? @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int?
  elementInstance    ElementInstance?  @relation(fields: [elementInstanceId], references: [id])
  elementInstanceId  Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, questionInstanceId])
}

model QuestionResponseDetail {
  id Int @id @default(autoincrement())

  score         Float  @default(0)
  pointsAwarded Float? @default(0)
  xpAwarded     Float  @default(0)

  /// [PrismaQuestionResponse]
  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  // TODO: for now, a response can be associated with either a questionInstance or elementInstance, but in the future only elementInstance will remain and be required
  questionInstance   QuestionInstance? @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int?
  elementInstance    ElementInstance?  @relation(fields: [elementInstanceId], references: [id])
  elementInstanceId  Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// #endregion

// ----- PUSH SUBSCRIPTIONS -----
// #region
model PushSubscription {
  id Int @id @default(autoincrement())

  endpoint       String
  expirationTime Int?
  p256dh         String
  auth           String

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())

  @@unique([participantId, courseId, endpoint])
}

// #endregion

// ----- ACHIEVEMENTS -----
// #region
enum AchievementType {
  PARTICIPANT // achievement awarded to individual participants
  GROUP // achievement awarded to a group of participants
  CLASS // achievement awarded on a global level (e.g., when reaching a class goal)
}

enum AchievementScope {
  GLOBAL // achievements defined at the application level
  COURSE // achievement defined at the course level
}

// Titles can be awarded to participants upon receipt of an achievement
// They are managed on a course-level
model Title {
  id Int @id @default(autoincrement())

  name      String
  awardedBy Achievement[]
  awardedTo Participant[]
  course    Course        @relation(fields: [courseId], references: [id])
  courseId  String        @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, name])
}

// Achievements are awarded to participants, groups, or classes
// They are managed on a course-level and can yield points for the leaderboard, individual XP, or titles
// TODO: add mechanisms to automate the awarding of achievements
model Achievement {
  id Int @id @default(autoincrement())

  name        String
  description String
  icon        String
  iconColor   String?

  rewardedPoints Int?
  rewardedXP     Int?
  rewardedTitles Title[]
  type           AchievementType
  scope          AchievementScope @default(GLOBAL)

  course   Course? @relation(fields: [courseId], references: [id])
  courseId String? @db.Uuid

  participantInstances ParticipantAchievementInstance[]
  groupInstances       GroupAchievementInstance[]
  classInstances       ClassAchievementInstance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ParticipantAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, achievementId])
}

model GroupAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  group   ParticipantGroup @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupId String           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId, achievementId])
}

model ClassAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, achievementId])
}

// #endregion

// ----- AWARDS -----
// #region
enum AwardType {
  PARTICIPANT
  GROUP
}

model AwardEntry {
  id Int @id @default(autoincrement())

  order       Int
  type        AwardType
  name        String
  displayName String
  description String

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id])
  participantId String?      @db.Uuid

  participantGroup   ParticipantGroup? @relation(fields: [participantGroupId], references: [id])
  participantGroupId String?           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, type, order])
  @@unique([courseId, type, name])
}

// #endregion

// ----- LEVELS -----
// #region
model Level {
  id Int @id @default(autoincrement())

  index      Int     @unique
  name       String?
  requiredXp Int
  avatar     String?

  nextLevel   Level?  @relation("level", fields: [nextLevelIx], references: [index])
  nextLevelIx Int?
  prevLevel   Level[] @relation("level")
}

// #endregion
