generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialIntegrity", "interactiveTransactions"]
  output          = "../client"
  binaryTargets   = ["native", "windows", "debian-openssl-1.1.x"]
}

generator erd {
  provider = "prisma-erd-generator"
}

datasource db {
  provider          = "postgres"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum UserRole {
  PARTICIPANT
  USER
  ADMIN
}

enum SSOType {
  Shibboleth
  LTI
}

model Account {
  id String @id @default(uuid()) @db.Uuid

  ssoType SSOType
  ssoId   String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @db.Uuid

  createdAt DateTime @default(now())
}

model User {
  id String @id @default(uuid()) @db.Uuid

  isActive Boolean @default(false)
  isAAI    Boolean @default(false)

  email               String    @unique
  shortname           String    @unique
  password            String
  description         String?
  lastLoginAt         DateTime?
  deletionToken       String?
  deletionRequestedAt DateTime?

  role UserRole @default(USER)

  accounts          Account[]
  courses           Course[]
  questions         Question[]
  attachments       Attachment[]
  tags              Tag[]
  questionInstances QuestionInstance[]
  sessions          Session[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- QUESTION MANAGEMENT -----

enum AttachmentType {
  PNG
  JPEG
  GIF
  LINK // embed videos, H5P, or similar
}

model Attachment {
  id String @id @default(uuid()) @db.Uuid

  href         String  @unique
  name         String
  originalName String?
  description  String?

  type AttachmentType

  question   Question? @relation(fields: [questionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  questionId Int?
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String    @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum QuestionType {
  SC
  MC
  FREE_TEXT
  NUMERICAL
}

model Question {
  id Int @id @default(autoincrement())

  isArchived Boolean @default(false)
  isDeleted  Boolean @default(false)

  name         String
  content      String
  contentPlain String
  options      Json

  type QuestionType

  attachments Attachment[]
  tags        Tag[]
  instances   QuestionInstance[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id Int @id @default(autoincrement())

  questions Question[]

  owner   User   @relation(fields: [ownerId], references: [id])
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model QuestionInstance {
  id Int @id @default(autoincrement())

  questionData Json
  participants Int                @default(0)
  results      Json
  responses    QuestionResponse[]

  sessionBlock      SessionBlock?    @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId    Int?
  learningElement   LearningElement? @relation(fields: [learningElementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  learningElementId String?          @db.Uuid
  microSession      MicroSession?    @relation(fields: [microSessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  microSessionId    String?          @db.Uuid

  question   Question? @relation(fields: [questionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  questionId Int?
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String    @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- INTERACTIONS -----

model Course {
  id String @id @default(uuid()) @db.Uuid

  isArchived Boolean @default(false)

  pinCode Int @default(1800)

  name        String
  displayName String
  description String?
  color       String?

  sessions         Session[]
  learningElements LearningElement[]
  microSessions    MicroSession[]
  leaderboard      LeaderboardEntry[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  participations Participation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum LeaderboardType {
  SESSION_BLOCK
  SESSION
  COURSE
}

model LeaderboardEntry {
  id Int @id @default(autoincrement())

  type LeaderboardType

  avatar   String?
  username String
  score    Float

  participant   Participant @relation(fields: [participantId], references: [id])
  participantId String      @db.Uuid

  sessionBlock   SessionBlock? @relation(fields: [sessionBlockId], references: [id])
  sessionBlockId Int?

  session   Session? @relation(fields: [sessionId], references: [id])
  sessionId String?  @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id])
  courseId String? @db.Uuid

  @@unique([type, participantId, sessionBlockId])
  @@unique([type, participantId, sessionId])
  @@unique([type, participantId, courseId])
}

enum SessionBlockStatus {
  SCHEDULED
  ACTIVE
  EXECUTED
}

model SessionBlock {
  id Int @id @default(autoincrement())

  status SessionBlockStatus @default(SCHEDULED)

  expiresAt       DateTime?
  timeLimit       Int?
  randomSelection Int?

  execution Int @default(0)

  instances   QuestionInstance[]
  leaderboard LeaderboardEntry[]

  activeInSession Session[] @relation(name: "ActiveSessionBlock")

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum SessionStatus {
  PREPARED
  SCHEDULED
  RUNNING
  COMPLETED
}

enum AccessMode {
  PUBLIC
  RESTRICTED
}

model Session {
  id String @id @default(uuid()) @db.Uuid

  isAudienceInteractionActive Boolean @default(false)
  isModerationEnabled         Boolean @default(true)
  isGamificationEnabled       Boolean @default(false)

  namespace   String    @default(uuid()) @db.Uuid
  pinCode     Int?
  name        String
  displayName String
  startedAt   DateTime?
  finishedAt  DateTime?

  accessMode AccessMode    @default(PUBLIC)
  status     SessionStatus @default(PREPARED)

  activeBlock   SessionBlock? @relation(name: "ActiveSessionBlock", fields: [activeBlockId], references: [id])
  activeBlockId Int?

  blocks      SessionBlock[]
  leaderboard LeaderboardEntry[]

  feedbacks Feedback[]

  confusionFeedbacks ConfusionTimestep[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LearningElement {
  id String @id @default(uuid()) @db.Uuid

  instances QuestionInstance[]

  owner    User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MicroSession {
  id String @id @default(uuid()) @db.Uuid

  name        String
  displayName String

  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  instances QuestionInstance[]

  owner    User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Feedback {
  id Int @id @default(autoincrement())

  isPublished Boolean @default(false)
  isPinned    Boolean @default(false)
  isResolved  Boolean @default(false)

  content String
  votes   Int    @default(0)

  responses FeedbackResponse[]

  resolvedAt DateTime?

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String?      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FeedbackResponse {
  id Int @id @default(autoincrement())

  content           String
  positiveReactions Int   @default(0)
  negativeReactions Int   @default(0)

  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  feedbackId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ConfusionTimestep {
  id Int @id @default(autoincrement())

  difficulty Int
  speed      Int

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String?      @db.Uuid

  createdAt DateTime @default(now())
}

// ----- PARTICIPANTS -----

model ParticipantAccount {
  id String @id @default(uuid()) @db.Uuid

  ssoType SSOType
  ssoId   String

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())

  @@unique([ssoType, ssoId])
}

model Participant {
  id String @id @default(uuid()) @db.Uuid

  username    String    @unique
  email       String    @unique
  password    String
  avatar      String    @default("placeholder.png")
  lastLoginAt DateTime?

  accounts           ParticipantAccount[]
  participations     Participation[]
  questionResponses  QuestionResponse[]
  feedbacks          Feedback[]
  confusionTimesteps ConfusionTimestep[]
  leaderboards       LeaderboardEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Participation {
  id Int @id @default(autoincrement())

  // enable participants to disable their participation
  // keeps the collected points but removes them from all views
  isActive Boolean @default(true)
  points   Int     @default(0)

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  responses QuestionResponse[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, participantId])
}

model QuestionResponse {
  id Int @id @default(autoincrement())

  trialsCount Int @default(0)

  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  questionInstance   QuestionInstance @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, questionInstanceId])
}
