generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex", "postgresqlExtensions", "fieldReference", "extendedWhereUnique"]
  output          = "../client"
  binaryTargets   = ["native", "windows", "debian-openssl-1.1.x", "linux-musl-openssl-3.0.x"]
}

generator pothos {
  provider     = "prisma-pothos-types"
  clientOutput = "@klicker-uzh/prisma"
  output       = "../client/pothos.d.ts"
}

datasource db {
  provider          = "postgres"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

// ----- USER ACCOUNTS -----

enum UserRole {
  PARTICIPANT
  USER
  ADMIN
}

model Account {
  id String @id @default(uuid()) @db.Uuid

  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Uuid

  @@unique([provider, providerAccountId])
}

model Session {
  id String @id @default(uuid()) @db.Uuid

  sessionToken String   @unique
  expires      DateTime

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Uuid
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserLoginScope {
  ACCOUNT_OWNER
  FULL_ACCESS
  SESSION_EXEC
  READ_ONLY
}

model UserLogin {
  id String @id @default(uuid()) @db.Uuid

  name        String         @default("-")
  password    String
  scope       UserLoginScope @default(READ_ONLY)
  lastLoginAt DateTime?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.Uuid
}

enum Locale {
  en
  de
}

model User {
  id String @id @default(uuid()) @db.Uuid

  originalId String? @unique

  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?

  shortname           String    @unique
  lastLoginAt         DateTime?
  deletionToken       String?
  deletionRequestedAt DateTime?
  loginToken          String?
  loginTokenExpiresAt DateTime?

  locale Locale @default(en)

  role UserRole @default(USER)

  catalystInstitutional Boolean @default(false)
  catalystIndividual    Boolean @default(false)
  catalystTier          String?

  logins            UserLogin[]
  session           Session[]
  accounts          Account[]
  courses           Course[]
  questions         Question[]
  mediaFiles        MediaFile[]
  tags              Tag[]
  questionInstances QuestionInstance[]
  sessions          LiveSession[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]
  groupActivities   GroupActivity[]

  firstLogin Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- MEDIA LIBRARY -----
model MediaFile {
  id String @id @default(uuid()) @db.Uuid

  href        String  @unique
  name        String
  type        String
  description String?

  originalId String? @unique

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- QUESTION POOL -----

enum QuestionType {
  SC
  MC
  KPRIM
  FREE_TEXT
  NUMERICAL
}

enum QuestionDisplayMode {
  LIST
  GRID
}

model Question {
  id Int @id @default(autoincrement())

  originalId String? @unique

  isArchived Boolean @default(false)
  isDeleted  Boolean @default(false)

  name               String
  content            String
  options            Json
  explanation        String?
  pointsMultiplier   Int                 @default(1)
  displayMode        QuestionDisplayMode @default(LIST)
  hasSampleSolution  Boolean             @default(false)
  hasAnswerFeedbacks Boolean             @default(false)

  type QuestionType

  tags      Tag[]
  instances QuestionInstance[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id   Int    @id @default(autoincrement())
  name String

  order Int @default(0)

  originalId String? @unique

  questions Question[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ownerId, name])
}

enum QuestionInstanceType {
  UNSET
  SESSION
  MICRO_SESSION
  LEARNING_ELEMENT
  GROUP_ACTIVITY
}

model QuestionInstance {
  id Int @id @default(autoincrement())

  originalId String? @unique

  type  QuestionInstanceType?
  order Int?

  questionData     Json
  participants     Int                      @default(0)
  pointsMultiplier Int                      @default(1)
  results          Json
  responses        QuestionResponse[]
  detailResponses  QuestionResponseDetail[]
  resetTimeDays    Int?

  sessionBlock    SessionBlock?  @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId  Int?
  stackElement    StackElement?  @relation(fields: [stackElementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  stackElementId  Int?           @unique
  microSession    MicroSession?  @relation(fields: [microSessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  microSessionId  String?        @db.Uuid
  groupActivity   GroupActivity? @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String?        @db.Uuid

  bookmarkedBy Participation[]

  question   Question? @relation(fields: [questionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  questionId Int?
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String    @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, sessionBlockId, order])
  @@unique([type, stackElementId, order])
  @@unique([type, microSessionId, order])
  @@unique([type, groupActivityId, order])
}

// TODO: think about usage of question stacks for group activities
enum QuestionStackType {
  LEARNING_ELEMENT
  MICRO_SESSION
  LIVE_SESSION
  GROUP_ACTIVITY
}

model QuestionStack {
  id Int @id @default(autoincrement())

  type        QuestionStackType
  displayName String?
  description String?
  order       Int?

  elements StackElement[]

  learningElement   LearningElement? @relation(fields: [learningElementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  learningElementId String?          @db.Uuid
  groupActivity     GroupActivity?

  bookmarkedBy Participation[]

  @@unique([type, learningElementId, order])
}

model StackElement {
  id Int @id @default(autoincrement())

  order Int?

  stack   QuestionStack @relation(fields: [stackId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  stackId Int

  mdContent String?

  questionInstance QuestionInstance?
}

// ----- COURSES -----

model Course {
  id String @id @default(uuid()) @db.Uuid

  isArchived Boolean @default(false)

  pinCode Int @unique

  name                  String
  displayName           String
  description           String?
  color                 String?   @default("#eaa07d")
  startDate             DateTime
  endDate               DateTime
  groupDeadlineDate     DateTime?
  notificationEmail     String?
  isGamificationEnabled Boolean   @default(true)

  sessions          LiveSession[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]
  leaderboard       LeaderboardEntry[]
  groupActivities   GroupActivity[]
  awards            AwardEntry[]
  classAchievements ClassAchievementInstance[]
  achievements      Achievement[]
  titles            Title[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  participations    Participation[]
  subscriptions     PushSubscription[]
  participantGroups ParticipantGroup[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// TODO: CourseInstance -> holds participants, leaderboards, instances, etc. (parallel courses, same course in repetition across years)

enum LeaderboardType {
  SESSION_BLOCK
  SESSION
  COURSE
}

model LeaderboardEntry {
  id Int @id @default(autoincrement())

  type LeaderboardType

  score Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation Participation?

  sessionParticipation   Participation? @relation("SessionLeaderboards", fields: [sessionParticipationId], references: [id])
  sessionParticipationId Int?

  sessionBlock   SessionBlock? @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId Int?

  session   LiveSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String?      @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  @@unique([type, participantId, sessionBlockId])
  @@unique([type, participantId, sessionId])
  @@unique([type, participantId, courseId])
}

// ----- SESSIONS -----

enum SessionBlockStatus {
  SCHEDULED
  ACTIVE
  EXECUTED
}

model SessionBlock {
  id Int @id @default(autoincrement())

  originalId String? @unique

  order  Int?
  status SessionBlockStatus @default(SCHEDULED)

  expiresAt       DateTime?
  timeLimit       Int?
  randomSelection Int?

  execution Int @default(0)

  instances   QuestionInstance[]
  leaderboard LeaderboardEntry[]

  activeInSession LiveSession[] @relation(name: "ActiveSessionBlock")

  session   LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, order])
}

enum SessionStatus {
  PREPARED
  SCHEDULED
  RUNNING
  COMPLETED
}

enum AccessMode {
  PUBLIC
  RESTRICTED
}

model LiveSession {
  id String @id @default(uuid()) @db.Uuid

  originalId                 String? @unique
  isLiveQAEnabled            Boolean @default(false)
  isConfusionFeedbackEnabled Boolean @default(true)
  isModerationEnabled        Boolean @default(true)
  isGamificationEnabled      Boolean @default(false)

  namespace        String    @default(uuid()) @db.Uuid
  pinCode          Int?
  name             String
  displayName      String
  description      String?
  startedAt        DateTime?
  finishedAt       DateTime?
  linkTo           String?
  pointsMultiplier Int       @default(1)

  accessMode AccessMode    @default(PUBLIC)
  status     SessionStatus @default(PREPARED)

  activeBlock   SessionBlock? @relation(name: "ActiveSessionBlock", fields: [activeBlockId], references: [id])
  activeBlockId Int?

  blocks      SessionBlock[]
  leaderboard LeaderboardEntry[]

  feedbacks Feedback[]

  confusionFeedbacks ConfusionTimestep[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- LEARNING ELEMENTS -----

enum OrderType {
  SEQUENTIAL
  SHUFFLED
  LAST_RESPONSE
}

enum LearningElementStatus {
  DRAFT
  PUBLISHED
}

model LearningElement {
  id String @id @default(uuid()) @db.Uuid

  name             String
  displayName      String
  description      String?
  pointsMultiplier Int                   @default(1)
  resetTimeDays    Int                   @default(6)
  orderType        OrderType             @default(SEQUENTIAL)
  status           LearningElementStatus @default(DRAFT)

  stacks QuestionStack[]

  owner    User    @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String  @db.Uuid
  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- MICROLEARNING -----

enum MicroSessionStatus {
  DRAFT
  PUBLISHED
}

model MicroSession {
  id String @id @default(uuid()) @db.Uuid

  name             String
  displayName      String
  pointsMultiplier Int                @default(1)
  description      String?
  status           MicroSessionStatus @default(DRAFT)

  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  arePushNotificationsSent Boolean @default(false)

  instances QuestionInstance[]

  owner    User    @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String  @db.Uuid
  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- GROUP ACTIVITIES -----

enum ParameterType {
  NUMBER
  STRING
}

model GroupActivityParameter {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type    ParameterType
  options String[]
  unit    String?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  @@unique([groupActivityId, name])
}

model GroupActivityClue {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type  ParameterType
  value String
  unit  String?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  @@unique([groupActivityId, name])
}

model GroupActivityClueInstance {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type  ParameterType
  value String
  unit  String?

  assignments             GroupActivityClueAssignment[]
  groupActivityInstance   GroupActivityInstance         @relation(fields: [groupActivityInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityInstanceId Int

  @@unique([groupActivityInstanceId, name])
}

enum GroupActivityStatus {
  DRAFT
  PUBLISHED
}

model GroupActivity {
  id String @id @default(uuid()) @db.Uuid

  name        String
  displayName String
  status      GroupActivityStatus @default(DRAFT)

  description      String?
  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  questionStack   QuestionStack? @relation(fields: [questionStackId], references: [id])
  questionStackId Int?           @unique

  parameters        GroupActivityParameter[]
  clues             GroupActivityClue[]
  instances         QuestionInstance[]
  activityInstances GroupActivityInstance[]

  owner    User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GroupActivityClueAssignment {
  id Int @id @default(autoincrement())

  groupActivityClueInstance   GroupActivityClueInstance @relation(fields: [groupActivityClueInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityClueInstanceId Int
  groupActivityInstance       GroupActivityInstance     @relation(fields: [groupActivityInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityInstanceId     Int
  participant                 Participant               @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId               String                    @db.Uuid
}

model GroupActivityInstance {
  id Int @id @default(autoincrement())

  clues                  GroupActivityClueInstance[]
  clueInstanceAssignment GroupActivityClueAssignment[]

  decisions            Json?
  decisionsSubmittedAt DateTime?
  results              Json?
  resultsComputedAt    DateTime?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  group   ParticipantGroup @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupId String           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupActivityId, groupId])
}

// ----- LIVE Q&A -----

model Feedback {
  id Int @id @default(autoincrement())

  isPublished Boolean @default(false)
  isPinned    Boolean @default(false)
  isResolved  Boolean @default(false)

  content String
  votes   Int    @default(0)

  responses FeedbackResponse[]

  resolvedAt DateTime?

  session   LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String      @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String?      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FeedbackResponse {
  id Int @id @default(autoincrement())

  content           String
  positiveReactions Int    @default(0)
  negativeReactions Int    @default(0)

  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  feedbackId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ConfusionTimestep {
  id Int @id @default(autoincrement())

  difficulty Int
  speed      Int

  session   LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String      @db.Uuid

  createdAt DateTime @default(now())
}

// ----- PARTICIPANTS -----
model ParticipantAccount {
  id String @id @default(uuid()) @db.Uuid

  ssoId String @unique

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())
}

model Participant {
  id String @id @default(uuid()) @db.Uuid

  email          String? @unique
  isEmailValid   Boolean @default(false)
  username       String  @unique
  password       String
  avatar         String?
  avatarSettings Json?
  xp             Int     @default(0)

  isActive        Boolean @default(true)
  isProfilePublic Boolean @default(true)
  isSSOAccount    Boolean @default(false)

  lastLoginAt DateTime?

  locale Locale @default(en)

  participantGroups       ParticipantGroup[]
  accounts                ParticipantAccount[]
  participations          Participation[]
  questionResponses       QuestionResponse[]
  detailQuestionResponses QuestionResponseDetail[]
  feedbacks               Feedback[]
  leaderboards            LeaderboardEntry[]
  subscriptions           PushSubscription[]
  clueAssignments         GroupActivityClueAssignment[]
  awards                  AwardEntry[]
  achievements            ParticipantAchievementInstance[]
  titles                  Title[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ParticipantGroup {
  id String @id @default(uuid()) @db.Uuid

  name String
  code Int

  groupActivityScore Float @default(0)
  averageMemberScore Float @default(0)

  participants    Participant[]
  groupActivities GroupActivityInstance[]
  awards          AwardEntry[]
  achievements    GroupAchievementInstance[]

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: SetNull)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, code])
}

model Participation {
  id Int @id @default(autoincrement())

  // enable participants to disable their participation
  // keeps the collected points but removes them from all views
  isActive Boolean @default(false)

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  courseLeaderboard   LeaderboardEntry? @relation(fields: [courseLeaderboardId], references: [id], onDelete: SetNull, onUpdate: SetNull)
  courseLeaderboardId Int?              @unique

  sessionLeaderboards LeaderboardEntry[] @relation("SessionLeaderboards")

  responses              QuestionResponse[]
  detailResponses        QuestionResponseDetail[]
  subscriptions          PushSubscription[]
  completedMicroSessions String[]
  bookmarkedQuestions    QuestionInstance[]
  bookmarkedStacks       QuestionStack[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, participantId])
}

// ----- ACHIEVEMENTS -----
enum AchievementType {
  PARTICIPANT // achievement awarded to individual participants
  GROUP // achievement awarded to a group of participants
  CLASS // achievement awarded on a global level (e.g., when reaching a class goal)
}

enum AchievementScope {
  GLOBAL // achievements defined at the application level
  COURSE // achievement defined at the course level
}

// Titles can be awarded to participants upon receipt of an achievement
// They are managed on a course-level
model Title {
  id Int @id @default(autoincrement())

  name      String
  awardedBy Achievement[]
  awardedTo Participant[]
  course    Course        @relation(fields: [courseId], references: [id])
  courseId  String        @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, name])
}

// Achievements are awarded to participants, groups, or classes
// They are managed on a course-level and can yield points for the leaderboard, individual XP, or titles
// TODO: add mechanisms to automate the awarding of achievements
model Achievement {
  id Int @id @default(autoincrement())

  name        String
  description String
  icon        String
  iconColor   String?

  rewardedPoints Int?
  rewardedXP     Int?
  rewardedTitles Title[]
  type           AchievementType
  scope          AchievementScope @default(GLOBAL)

  course   Course? @relation(fields: [courseId], references: [id])
  courseId String? @db.Uuid

  participantInstances ParticipantAchievementInstance[]
  groupInstances       GroupAchievementInstance[]
  classInstances       ClassAchievementInstance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ParticipantAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, achievementId])
}

model GroupAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  group   ParticipantGroup @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupId String           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId, achievementId])
}

model ClassAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, achievementId])
}

// ----- RESPONSE TRACKING -----

model QuestionResponse {
  id Int @id @default(autoincrement())

  trialsCount        Int       @default(0)
  totalScore         Float     @default(0)
  totalPointsAwarded Float?    @default(0)
  totalXpAwarded     Float     @default(0)
  lastAwardedAt      DateTime?
  lastXpAwardedAt    DateTime?

  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  questionInstance   QuestionInstance @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, questionInstanceId])
}

model QuestionResponseDetail {
  id Int @id @default(autoincrement())

  score         Float  @default(0)
  pointsAwarded Float? @default(0)
  xpAwarded     Float  @default(0)

  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  questionInstance   QuestionInstance @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- PUSH SUBSCRIPTIONS -----

model PushSubscription {
  id Int @id @default(autoincrement())

  endpoint       String
  expirationTime Int?
  p256dh         String
  auth           String

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())

  @@unique([participantId, courseId, endpoint])
}

// ----- AWARDS -----
enum AwardType {
  PARTICIPANT
  GROUP
}

model AwardEntry {
  id Int @id @default(autoincrement())

  order       Int
  type        AwardType
  name        String
  displayName String
  description String

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id])
  participantId String?      @db.Uuid

  participantGroup   ParticipantGroup? @relation(fields: [participantGroupId], references: [id])
  participantGroupId String?           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, type, order])
  @@unique([courseId, type, name])
}

// ----- LEVELS -----
model Level {
  id Int @id @default(autoincrement())

  index      Int     @unique
  name       String?
  requiredXp Int
  avatar     String?

  nextLevel   Level?  @relation("level", fields: [nextLevelIx], references: [index])
  nextLevelIx Int?
  prevLevel   Level[] @relation("level")
}
