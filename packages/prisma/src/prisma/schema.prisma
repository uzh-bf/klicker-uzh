generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex", "postgresqlExtensions", "fieldReference", "orderByNulls", "extendedWhereUnique"]
  output          = "../client"
  binaryTargets   = ["native", "windows", "debian-openssl-1.1.x", "linux-musl-openssl-3.0.x"]
}

generator erd {
  provider = "prisma-erd-generator"
}

generator pothos {
  provider     = "prisma-pothos-types"
  clientOutput = "@klicker-uzh/prisma"
  output       = "../client/pothos.d.ts"
}

datasource db {
  provider          = "postgres"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

// ----- USER ACCOUNTS -----

enum UserRole {
  PARTICIPANT
  USER
  ADMIN
}

enum SSOType {
  Shibboleth
  LTI
}

model Account {
  id String @id @default(uuid()) @db.Uuid

  ssoType SSOType
  ssoId   String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @db.Uuid

  createdAt DateTime @default(now())
}

model User {
  id String @id @default(uuid()) @db.Uuid

  isActive Boolean @default(false)
  isAAI    Boolean @default(false)

  email               String    @unique
  shortname           String    @unique
  password            String
  description         String?
  lastLoginAt         DateTime?
  deletionToken       String?
  deletionRequestedAt DateTime?
  loginToken          String?
  loginTokenExpiresAt DateTime?

  role UserRole @default(USER)

  accounts          Account[]
  courses           Course[]
  questions         Question[]
  attachments       Attachment[]
  tags              Tag[]
  questionInstances QuestionInstance[]
  sessions          Session[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]
  groupActivities   GroupActivity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- QUESTION POOL -----

enum AttachmentType {
  PNG
  JPEG
  SVG
  WEBP
  GIF
  LINK // embed videos, H5P, or similar
}

model Attachment {
  id String @id @default(uuid()) @db.Uuid

  href         String  @unique
  name         String
  originalName String?
  description  String?

  type AttachmentType

  question   Question? @relation(fields: [questionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionId Int?
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String    @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AttachmentInstance {
  id String @id @default(uuid()) @db.Uuid

  href         String
  name         String
  originalName String?
  description  String?

  type AttachmentType

  questionInstance   QuestionInstance? @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum QuestionType {
  SC
  MC
  KPRIM
  FREE_TEXT
  NUMERICAL
}

enum QuestionDisplayMode {
  LIST
  GRID
}

model Question {
  id Int @id @default(autoincrement())

  isArchived Boolean @default(false)
  isDeleted  Boolean @default(false)

  name               String
  content            String
  options            Json
  explanation        String?
  pointsMultiplier   Int                 @default(1)
  displayMode        QuestionDisplayMode @default(LIST)
  hasSampleSolution  Boolean             @default(false)
  hasAnswerFeedbacks Boolean             @default(false)

  type QuestionType

  attachments Attachment[]
  tags        Tag[]
  instances   QuestionInstance[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id   Int    @id @default(autoincrement())
  name String

  questions Question[]

  owner   User   @relation(fields: [ownerId], references: [id])
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ownerId, name])
}

enum QuestionInstanceType {
  UNSET
  SESSION
  MICRO_SESSION
  LEARNING_ELEMENT
  GROUP_ACTIVITY
}

model QuestionInstance {
  id Int @id @default(autoincrement())

  type  QuestionInstanceType?
  order Int?

  questionData     Json
  participants     Int                      @default(0)
  pointsMultiplier Int                      @default(1)
  results          Json
  responses        QuestionResponse[]
  detailResponses  QuestionResponseDetail[]
  resetTimeDays    Int?

  sessionBlock      SessionBlock?    @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId    Int?
  learningElement   LearningElement? @relation(fields: [learningElementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  learningElementId String?          @db.Uuid
  microSession      MicroSession?    @relation(fields: [microSessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  microSessionId    String?          @db.Uuid
  groupActivity     GroupActivity?   @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId   String?          @db.Uuid

  attachments  AttachmentInstance[]
  bookmarkedBy Participation[]

  question   Question? @relation(fields: [questionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  questionId Int?
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String    @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, sessionBlockId, order])
  @@unique([type, learningElementId, order])
  @@unique([type, microSessionId, order])
  @@unique([type, groupActivityId, order])
}

// ----- COURSES -----

model Course {
  id String @id @default(uuid()) @db.Uuid

  isArchived Boolean @default(false)

  pinCode Int @unique @default(123456789)

  name              String
  displayName       String
  description       String?
  color             String?  @default("#eaa07d")
  startDate         DateTime
  endDate           DateTime
  notificationEmail String?

  sessions          Session[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]
  leaderboard       LeaderboardEntry[]
  groupActivities   GroupActivity[]
  awards            AwardEntry[]
  classAchievements ClassAchievementInstance[]
  achievements      Achievement[]
  titles            Title[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  participations    Participation[]
  subscriptions     PushSubscription[]
  participantGroups ParticipantGroup[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// TODO: CourseInstance -> holds participants, leaderboards, instances, etc. (parallel courses, same course in repetition across years)

enum LeaderboardType {
  SESSION_BLOCK
  SESSION
  COURSE
}

model LeaderboardEntry {
  id Int @id @default(autoincrement())

  type LeaderboardType

  score Float

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation Participation?

  sessionParticipation   Participation? @relation("SessionLeaderboards", fields: [sessionParticipationId], references: [id])
  sessionParticipationId Int?

  sessionBlock   SessionBlock? @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId Int?

  session   Session? @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String?  @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  @@unique([type, participantId, sessionBlockId])
  @@unique([type, participantId, sessionId])
  @@unique([type, participantId, courseId])
}

// ----- SESSIONS -----

enum SessionBlockStatus {
  SCHEDULED
  ACTIVE
  EXECUTED
}

model SessionBlock {
  id Int @id @default(autoincrement())

  order  Int?
  status SessionBlockStatus @default(SCHEDULED)

  expiresAt       DateTime?
  timeLimit       Int?
  randomSelection Int?

  execution Int @default(0)

  instances   QuestionInstance[]
  leaderboard LeaderboardEntry[]

  activeInSession Session[] @relation(name: "ActiveSessionBlock")

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, order])
}

enum SessionStatus {
  PREPARED
  SCHEDULED
  RUNNING
  COMPLETED
}

enum AccessMode {
  PUBLIC
  RESTRICTED
}

model Session {
  id String @id @default(uuid()) @db.Uuid

  isLiveQAEnabled            Boolean @default(false)
  isConfusionFeedbackEnabled Boolean @default(true)
  isModerationEnabled        Boolean @default(true)
  isGamificationEnabled      Boolean @default(false)

  namespace        String    @default(uuid()) @db.Uuid
  pinCode          Int?
  name             String
  displayName      String
  description      String?
  startedAt        DateTime?
  finishedAt       DateTime?
  linkTo           String?
  pointsMultiplier Int       @default(1)

  accessMode AccessMode    @default(PUBLIC)
  status     SessionStatus @default(PREPARED)

  activeBlock   SessionBlock? @relation(name: "ActiveSessionBlock", fields: [activeBlockId], references: [id])
  activeBlockId Int?

  blocks      SessionBlock[]
  leaderboard LeaderboardEntry[]

  feedbacks Feedback[]

  confusionFeedbacks ConfusionTimestep[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- LEARNING ELEMENTS -----

enum OrderType {
  SEQUENTIAL
  SHUFFLED
  LAST_RESPONSE
}

model LearningElement {
  id String @id @default(uuid()) @db.Uuid

  name             String
  displayName      String
  description      String?
  pointsMultiplier Int       @default(1)
  resetTimeDays    Int       @default(6)
  orderType        OrderType @default(SEQUENTIAL)

  instances QuestionInstance[]

  owner    User    @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String  @db.Uuid
  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- MICROLEARNING -----

model MicroSession {
  id String @id @default(uuid()) @db.Uuid

  name             String
  displayName      String
  pointsMultiplier Int     @default(1)
  description      String?

  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  instances QuestionInstance[]

  owner    User    @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String  @db.Uuid
  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- GROUP ACTIVITIES -----

enum ParameterType {
  NUMBER
  STRING
}

model GroupActivityParameter {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type    ParameterType
  options String[]
  unit    String?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  @@unique([groupActivityId, name])
}

model GroupActivityClue {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type  ParameterType
  value String
  unit  String?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  @@unique([groupActivityId, name])
}

model GroupActivityClueInstance {
  id Int @id @default(autoincrement())

  name        String
  displayName String

  type  ParameterType
  value String
  unit  String?

  assignments             GroupActivityClueAssignment[]
  groupActivityInstance   GroupActivityInstance         @relation(fields: [groupActivityInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityInstanceId Int

  @@unique([groupActivityInstanceId, name])
}

model GroupActivity {
  id String @id @default(uuid()) @db.Uuid

  name        String
  displayName String

  description      String?
  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  parameters        GroupActivityParameter[]
  clues             GroupActivityClue[]
  instances         QuestionInstance[]
  activityInstances GroupActivityInstance[]

  owner    User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GroupActivityClueAssignment {
  id Int @id @default(autoincrement())

  groupActivityClueInstance   GroupActivityClueInstance @relation(fields: [groupActivityClueInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityClueInstanceId Int
  groupActivityInstance       GroupActivityInstance     @relation(fields: [groupActivityInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityInstanceId     Int
  participant                 Participant               @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId               String                    @db.Uuid
}

model GroupActivityInstance {
  id Int @id @default(autoincrement())

  clues                  GroupActivityClueInstance[]
  clueInstanceAssignment GroupActivityClueAssignment[]

  decisions            Json?
  decisionsSubmittedAt DateTime?
  results              Json?
  resultsComputedAt    DateTime?

  groupActivity   GroupActivity @relation(fields: [groupActivityId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupActivityId String        @db.Uuid

  group   ParticipantGroup @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupId String           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupActivityId, groupId])
}

// ----- LIVE Q&A -----

model Feedback {
  id Int @id @default(autoincrement())

  isPublished Boolean @default(false)
  isPinned    Boolean @default(false)
  isResolved  Boolean @default(false)

  content String
  votes   Int    @default(0)

  responses FeedbackResponse[]

  resolvedAt DateTime?

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String?      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FeedbackResponse {
  id Int @id @default(autoincrement())

  content           String
  positiveReactions Int    @default(0)
  negativeReactions Int    @default(0)

  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  feedbackId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ConfusionTimestep {
  id Int @id @default(autoincrement())

  difficulty Int
  speed      Int

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  createdAt DateTime @default(now())
}

// ----- PARTICIPANTS -----

model ParticipantAccount {
  id String @id @default(uuid()) @db.Uuid

  ssoType SSOType
  ssoId   String

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())

  @@unique([ssoType, ssoId])
}

model Participant {
  id String @id @default(uuid()) @db.Uuid

  username       String  @unique
  password       String
  avatar         String?
  avatarSettings Json?
  xp             Int     @default(0)

  lastLoginAt DateTime?

  participantGroups       ParticipantGroup[]
  accounts                ParticipantAccount[]
  participations          Participation[]
  questionResponses       QuestionResponse[]
  detailQuestionResponses QuestionResponseDetail[]
  feedbacks               Feedback[]
  leaderboards            LeaderboardEntry[]
  subscriptions           PushSubscription[]
  clueAssignments         GroupActivityClueAssignment[]
  awards                  AwardEntry[]
  achievements            ParticipantAchievementInstance[]
  titles                  Title[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ParticipantGroup {
  id String @id @default(uuid()) @db.Uuid

  name String
  code Int

  groupActivityScore Float @default(0)
  averageMemberScore Float @default(0)

  participants    Participant[]
  groupActivities GroupActivityInstance[]
  awards          AwardEntry[]
  achievements    GroupAchievementInstance[]

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: SetNull)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, code])
}

model Participation {
  id Int @id @default(autoincrement())

  // enable participants to disable their participation
  // keeps the collected points but removes them from all views
  isActive Boolean @default(true)

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  courseLeaderboard   LeaderboardEntry? @relation(fields: [courseLeaderboardId], references: [id])
  courseLeaderboardId Int?              @unique

  sessionLeaderboards LeaderboardEntry[] @relation("SessionLeaderboards")

  responses              QuestionResponse[]
  detailResponses        QuestionResponseDetail[]
  subscriptions          PushSubscription[]
  completedMicroSessions String[]

  bookmarkedQuestions QuestionInstance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, participantId])
}

// ----- ACHIEVEMENTS -----
enum AchievementType {
  PARTICIPANT // achievement awarded to individual participants
  GROUP // achievement awarded to a group of participants
  CLASS // achievement awarded on a global level (e.g., when reaching a class goal)
}

enum AchievementScope {
  GLOBAL // achievements defined at the application level
  COURSE // achievement defined at the course level
}

// Titles can be awarded to participants upon receipt of an achievement
// They are managed on a course-level
model Title {
  id Int @id @default(autoincrement())

  name      String
  awardedBy Achievement[]
  awardedTo Participant[]
  course    Course        @relation(fields: [courseId], references: [id])
  courseId  String        @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, name])
}

// Achievements are awarded to participants, groups, or classes
// They are managed on a course-level and can yield points for the leaderboard, individual XP, or titles
// TODO: add mechanisms to automate the awarding of achievements
model Achievement {
  id Int @id @default(autoincrement())

  name        String
  description String
  icon        String
  iconColor   String?

  rewardedPoints Int?
  rewardedXP     Int?
  rewardedTitles Title[]
  type           AchievementType
  scope          AchievementScope @default(GLOBAL)

  course   Course? @relation(fields: [courseId], references: [id])
  courseId String? @db.Uuid

  participantInstances ParticipantAchievementInstance[]
  groupInstances       GroupAchievementInstance[]
  classInstances       ClassAchievementInstance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ParticipantAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, achievementId])
}

model GroupAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  group   ParticipantGroup @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  groupId String           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId, achievementId])
}

model ClassAchievementInstance {
  id Int @id @default(autoincrement())

  achievedAt    DateTime
  achievedCount Int      @default(1)

  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  achievementId Int

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, achievementId])
}

// ----- RESPONSE TRACKING -----

model QuestionResponse {
  id Int @id @default(autoincrement())

  trialsCount        Int       @default(0)
  totalScore         Float     @default(0)
  totalPointsAwarded Float     @default(0)
  totalXpAwarded     Float     @default(0)
  lastAwardedAt      DateTime?
  lastXpAwardedAt    DateTime?

  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  questionInstance   QuestionInstance @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, questionInstanceId])
}

model QuestionResponseDetail {
  id Int @id @default(autoincrement())

  score         Float @default(0)
  pointsAwarded Float @default(0)
  xpAwarded     Float @default(0)

  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  questionInstance   QuestionInstance @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- PUSH SUBSCRIPTIONS -----

model PushSubscription {
  id Int @id @default(autoincrement())

  endpoint       String
  expirationTime Int?
  p256dh         String
  auth           String

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())

  @@unique([participantId, courseId, endpoint])
}

// ----- AWARDS -----
enum AwardType {
  PARTICIPANT
  GROUP
}

model AwardEntry {
  id Int @id @default(autoincrement())

  order       Int
  type        AwardType
  name        String
  displayName String
  description String

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id])
  participantId String?      @db.Uuid

  participantGroup   ParticipantGroup? @relation(fields: [participantGroupId], references: [id])
  participantGroupId String?           @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, type, order])
  @@unique([courseId, type, name])
}
