generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex", "interactiveTransactions", "postgresqlExtensions", "fieldReference", "orderByNulls", "extendedWhereUnique"]
  output          = "../client"
  binaryTargets   = ["native", "windows", "debian-openssl-1.1.x", "linux-musl"]
}

generator erd {
  provider = "prisma-erd-generator"
}

datasource db {
  provider          = "postgres"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum UserRole {
  PARTICIPANT
  USER
  ADMIN
}

enum SSOType {
  Shibboleth
  LTI
}

model Account {
  id String @id @default(uuid()) @db.Uuid

  ssoType SSOType
  ssoId   String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @db.Uuid

  createdAt DateTime @default(now())
}

model User {
  id String @id @default(uuid()) @db.Uuid

  isActive Boolean @default(false)
  isAAI    Boolean @default(false)

  email               String    @unique
  shortname           String    @unique
  password            String
  description         String?
  lastLoginAt         DateTime?
  deletionToken       String?
  deletionRequestedAt DateTime?

  role UserRole @default(USER)

  accounts          Account[]
  courses           Course[]
  questions         Question[]
  attachments       Attachment[]
  tags              Tag[]
  questionInstances QuestionInstance[]
  sessions          Session[]
  learningElements  LearningElement[]
  microSessions     MicroSession[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ----- QUESTION MANAGEMENT -----

enum AttachmentType {
  PNG
  JPEG
  SVG
  WEBP
  GIF
  LINK // embed videos, H5P, or similar
}

model Attachment {
  id String @id @default(uuid()) @db.Uuid

  href         String  @unique
  name         String
  originalName String?
  description  String?

  type AttachmentType

  question   Question? @relation(fields: [questionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionId Int?
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String    @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AttachmentInstance {
  id String @id @default(uuid()) @db.Uuid

  href         String
  name         String
  originalName String?
  description  String?

  type AttachmentType

  questionInstance   QuestionInstance? @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum QuestionType {
  SC
  MC
  KPRIM
  FREE_TEXT
  NUMERICAL
}

model Question {
  id Int @id @default(autoincrement())

  isArchived Boolean @default(false)
  isDeleted  Boolean @default(false)

  name    String
  content String
  options Json

  hasSampleSolution  Boolean @default(false)
  hasAnswerFeedbacks Boolean @default(false)

  type QuestionType

  attachments Attachment[]
  tags        Tag[]
  instances   QuestionInstance[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id   Int    @id @default(autoincrement())
  name String

  questions Question[]

  owner   User   @relation(fields: [ownerId], references: [id])
  ownerId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ownerId, name])
}

enum QuestionInstanceType {
  UNSET
  SESSION
  MICRO_SESSION
  LEARNING_ELEMENT
}

model QuestionInstance {
  id Int @id @default(autoincrement())

  type  QuestionInstanceType?
  order Int?

  questionData    Json
  participants    Int                      @default(0)
  results         Json
  responses       QuestionResponse[]
  detailResponses QuestionResponseDetail[]

  sessionBlock      SessionBlock?    @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId    Int?
  learningElement   LearningElement? @relation(fields: [learningElementId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  learningElementId String?          @db.Uuid
  microSession      MicroSession?    @relation(fields: [microSessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  microSessionId    String?          @db.Uuid

  attachments AttachmentInstance[]

  question   Question? @relation(fields: [questionId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  questionId Int?
  owner      User      @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId    String    @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, sessionBlockId, order])
  @@unique([type, learningElementId, order])
  @@unique([type, microSessionId, order])
}

// ----- INTERACTIONS -----

model Course {
  id String @id @default(uuid()) @db.Uuid

  isArchived Boolean @default(false)

  pinCode Int @default(1800)

  name        String
  displayName String
  description String?
  color       String?

  sessions         Session[]
  learningElements LearningElement[]
  microSessions    MicroSession[]
  leaderboard      LeaderboardEntry[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  participations    Participation[]
  subscriptions     PushSubscription[]
  participantGroups ParticipantGroup[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum LeaderboardType {
  SESSION_BLOCK
  SESSION
  COURSE
}

model LeaderboardEntry {
  id Int @id @default(autoincrement())

  type LeaderboardType

  score Float

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation Participation?

  sessionParticipation   Participation? @relation("SessionLeaderboards", fields: [sessionParticipationId], references: [id])
  sessionParticipationId Int?

  sessionBlock   SessionBlock? @relation(fields: [sessionBlockId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionBlockId Int?

  session   Session? @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String?  @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  @@unique([type, participantId, sessionBlockId])
  @@unique([type, participantId, sessionId])
  @@unique([type, participantId, courseId])
}

enum SessionBlockStatus {
  SCHEDULED
  ACTIVE
  EXECUTED
}

model SessionBlock {
  id Int @id @default(autoincrement())

  order  Int?
  status SessionBlockStatus @default(SCHEDULED)

  expiresAt       DateTime?
  timeLimit       Int?
  randomSelection Int?

  execution Int @default(0)

  instances   QuestionInstance[]
  leaderboard LeaderboardEntry[]

  activeInSession Session[] @relation(name: "ActiveSessionBlock")

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, order])
}

enum SessionStatus {
  PREPARED
  SCHEDULED
  RUNNING
  COMPLETED
}

enum AccessMode {
  PUBLIC
  RESTRICTED
}

model Session {
  id String @id @default(uuid()) @db.Uuid

  isAudienceInteractionActive Boolean @default(false)
  isModerationEnabled         Boolean @default(true)
  isGamificationEnabled       Boolean @default(false)

  namespace   String    @default(uuid()) @db.Uuid
  pinCode     Int?
  name        String
  displayName String
  startedAt   DateTime?
  finishedAt  DateTime?
  linkTo      String?

  accessMode AccessMode    @default(PUBLIC)
  status     SessionStatus @default(PREPARED)

  activeBlock   SessionBlock? @relation(name: "ActiveSessionBlock", fields: [activeBlockId], references: [id])
  activeBlockId Int?

  blocks      SessionBlock[]
  leaderboard LeaderboardEntry[]

  feedbacks Feedback[]

  confusionFeedbacks ConfusionTimestep[]

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String @db.Uuid

  course   Course? @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String? @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LearningElement {
  id String @id @default(uuid()) @db.Uuid

  name        String
  displayName String
  instances   QuestionInstance[]

  owner    User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MicroSession {
  id String @id @default(uuid()) @db.Uuid

  name        String
  displayName String

  description String?

  scheduledStartAt DateTime
  scheduledEndAt   DateTime

  instances QuestionInstance[]

  owner    User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId  String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Feedback {
  id Int @id @default(autoincrement())

  isPublished Boolean @default(false)
  isPinned    Boolean @default(false)
  isResolved  Boolean @default(false)

  content String
  votes   Int    @default(0)

  responses FeedbackResponse[]

  resolvedAt DateTime?

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  participant   Participant? @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String?      @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FeedbackResponse {
  id Int @id @default(autoincrement())

  content           String
  positiveReactions Int    @default(0)
  negativeReactions Int    @default(0)

  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  feedbackId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ConfusionTimestep {
  id Int @id @default(autoincrement())

  difficulty Int
  speed      Int

  session   Session @relation(fields: [sessionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  sessionId String  @db.Uuid

  createdAt DateTime @default(now())
}

// ----- PARTICIPANTS -----

model ParticipantAccount {
  id String @id @default(uuid()) @db.Uuid

  ssoType SSOType
  ssoId   String

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())

  @@unique([ssoType, ssoId])
}

model Participant {
  id String @id @default(uuid()) @db.Uuid

  username       String  @unique
  password       String
  avatar         String?
  avatarSettings Json?

  lastLoginAt DateTime?

  participantGroups       ParticipantGroup[]
  accounts                ParticipantAccount[]
  participations          Participation[]
  questionResponses       QuestionResponse[]
  detailQuestionResponses QuestionResponseDetail[]
  feedbacks               Feedback[]
  leaderboards            LeaderboardEntry[]
  subscriptions           PushSubscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ParticipantGroup {
  id String @id @default(uuid()) @db.Uuid

  name String
  code Int

  groupActivityScore Float @default(0)
  averageMemberScore Float @default(0)

  participants Participant[]

  course   Course @relation(fields: [courseId], references: [id], onDelete: SetNull, onUpdate: SetNull)
  courseId String @db.Uuid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, code])
}

model Participation {
  id Int @id @default(autoincrement())

  // enable participants to disable their participation
  // keeps the collected points but removes them from all views
  isActive Boolean @default(true)

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  courseLeaderboard   LeaderboardEntry? @relation(fields: [courseLeaderboardId], references: [id])
  courseLeaderboardId Int?              @unique

  sessionLeaderboards LeaderboardEntry[] @relation("SessionLeaderboards")

  responses              QuestionResponse[]
  detailResponses        QuestionResponseDetail[]
  subscriptions          PushSubscription[]
  completedMicroSessions String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseId, participantId])
}

model QuestionResponse {
  id Int @id @default(autoincrement())

  trialsCount        Int       @default(0)
  totalScore         Float     @default(0)
  totalPointsAwarded Float     @default(0)
  lastAwardedAt      DateTime?

  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  questionInstance   QuestionInstance @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([participantId, questionInstanceId])
}

model QuestionResponseDetail {
  id Int @id @default(autoincrement())

  score         Float @default(0)
  pointsAwarded Float @default(0)

  response Json

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  questionInstance   QuestionInstance @relation(fields: [questionInstanceId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  questionInstanceId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PushSubscription {
  id Int @id @default(autoincrement())

  endpoint       String
  expirationTime Int?
  p256dh         String
  auth           String

  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  courseId String @db.Uuid

  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participationId Int

  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  participantId String      @db.Uuid

  createdAt DateTime @default(now())

  @@unique([participantId, courseId, endpoint])
}
