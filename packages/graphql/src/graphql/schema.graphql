### This file was generated by Nexus Schema
### Do not make changes to this file directly


enum AccessMode {
  PUBLIC
  RESTRICTED
}

type AggregatedConfusionFeedbacks {
  difficulty: Float!
  numberOfParticipants: Int!
  speed: Float!
  timestamp: DateTime
}

type Attachment {
  description: String
  href: String!
  id: String!
  name: String!
  originalName: String
  type: AttachmentType!
}

enum AttachmentType {
  GIF
  JPEG
  LINK
  PNG
  SVG
  WEBP
}

input AvatarSettingsInput {
  accessory: String!
  clothing: String!
  clothingColor: String!
  eyes: String!
  facialHair: String!
  hair: String!
  hairColor: String!
  mouth: String!
  skinTone: String!
}

input BlockInput {
  questionIds: [Int!]!
  randomSelection: Int
  timeLimit: Int
}

type Choice {
  correct: Boolean
  feedback: String
  id: ID!
  ix: Int!
  value: String!
}

type ChoicesQuestionData implements QuestionData {
  content: String!
  contentPlain: String!
  id: Int!
  isArchived: Boolean!
  isDeleted: Boolean!
  name: String!
  options: ChoicesQuestionOptions!
  type: String!
}

type ChoicesQuestionOptions {
  choices: [Choice!]!
}

type ConfusionTimestep {
  createdAt: DateTime!
  difficulty: Int!
  id: Int!
  speed: Int!
}

type Course {
  color: String
  displayName: String!
  id: ID!
  learningElements: [LearningElement!]!
  microSessions: [MicroSession!]!
  name: String!
  sessions: [Session!]!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type Feedback {
  content: String!
  createdAt: DateTime
  id: Int!
  isPinned: Boolean!
  isPublished: Boolean!
  isResolved: Boolean!
  resolvedAt: DateTime
  responses: [FeedbackResponse]
  updatedAt: DateTime
  votes: Int!
}

type FeedbackResponse {
  content: String!
  createdAt: DateTime!
  id: Int!
  negativeReactions: Int!
  positiveReactions: Int!
  resolvedAt: DateTime
}

type FreeTextQuestionData implements QuestionData {
  content: String!
  contentPlain: String!
  id: Int!
  isArchived: Boolean!
  isDeleted: Boolean!
  name: String!
  options: FreeTextQuestionOptions!
  type: String!
}

type FreeTextQuestionOptions {
  restrictions: FreeTextRestrictions
  solutions: [String!]
}

type FreeTextRestrictions {
  maxLength: Int
}

type InstanceEvaluation {
  choices: JSONObject!
  feedbacks: [QuestionFeedback!]
  newPointsFrom: DateTime
  percentile: Float
  pointsAwarded: Float
  score: Float!
}

type InstanceResults {
  blockIx: Int!
  id: ID!
  instanceIx: Int!
  questionData: QuestionData!
  results: JSONObject!
  status: SessionBlockStatus!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type LeaderboardEntry {
  avatar: String
  id: ID!
  isSelf: Boolean
  participantId: ID!
  score: Float!
  username: String!
}

type LearningElement {
  course: Course!
  displayName: String!
  id: ID!
  instances: [QuestionInstance!]!
  name: String!
}

type MicroSession {
  course: Course!
  description: String
  displayName: String!
  id: ID!
  instances: [QuestionInstance!]!
  name: String!
  scheduledEndAt: DateTime!
  scheduledStartAt: DateTime!
}

type Mutation {
  activateSessionBlock(sessionBlockId: Int!, sessionId: ID!): Session
  addConfusionTimestep(difficulty: Int!, sessionId: ID!, speed: Int!): ConfusionTimestep
  changeSessionSettings(id: ID!, isAudienceInteractionActive: Boolean, isGamificationEnabled: Boolean, isModerationEnabled: Boolean): Session
  createCourse(color: String, displayName: String, name: String!): Course
  createFeedback(content: String!, sessionId: ID!): Feedback
  createSession(blocks: [BlockInput!]!, courseId: String, displayName: String, name: String!): Session
  deactivateSessionBlock(sessionBlockId: Int!, sessionId: ID!): Session
  deleteFeedback(id: Int!): Feedback
  deleteFeedbackResponse(id: Int!): Feedback
  endSession(id: ID!): Session
  joinCourse(courseId: ID!): ParticipantLearningData
  leaveCourse(courseId: ID!): ParticipantLearningData
  loginParticipant(password: String!, username: String!): ID
  loginUser(email: String!, password: String!): ID
  logoutParticipant: ID
  logoutUser: ID
  markMicroSessionCompleted(courseId: ID!, id: ID!): Participation
  pinFeedback(id: Int!, isPinned: Boolean!): Feedback
  publishFeedback(id: Int!, isPublished: Boolean!): Feedback
  registerParticipantFromLTI(courseId: ID!, participantId: ID!): ParticipantLearningData
  resolveFeedback(id: Int!, isResolved: Boolean!): Feedback
  respondToFeedback(id: Int!, responseContent: String!): Feedback
  respondToQuestionInstance(courseId: ID!, id: Int!, response: ResponseInput!): QuestionInstance
  startSession(id: ID!): Session
  subscribeToPush(courseId: ID!, subscriptionObject: SubscriptionObjectInput!): Participation
  updateParticipantProfile(avatar: String, avatarSettings: AvatarSettingsInput, password: String, username: String): Participant
  upvoteFeedback(feedbackId: Int!, increment: Int!): Feedback
  voteFeedbackResponse(id: Int!, incrementDownvote: Int!, incrementUpvote: Int!): FeedbackResponse
}

type NumericalQuestionData implements QuestionData {
  content: String!
  contentPlain: String!
  id: Int!
  isArchived: Boolean!
  isDeleted: Boolean!
  name: String!
  options: NumericalQuestionOptions!
  type: String!
}

type NumericalQuestionOptions {
  restrictions: NumericalRestrictions
  solutionRanges: [NumericalSolutionRange!]
}

type NumericalRestrictions {
  max: Int
  min: Int
}

type NumericalSolutionRange {
  max: Float
  min: Float
}

type Participant {
  avatar: String
  avatarSettings: JSONObject
  id: ID!
  username: String!
}

type ParticipantLearningData {
  course: Course
  id: ID!
  leaderboard: [LeaderboardEntry!]
  participant: Participant
  participantToken: String
  participation: Participation
}

type Participation {
  completedMicroSessions: [String]
  course: Course
  id: Int!
  isActive: Boolean!
  subscriptions: [PublicSubscriptionData!]
}

type PublicSubscriptionData {
  endpoint: String!
  id: Int!
}

type PushSubscription {
  auth: String!
  endpoint: String!
  expirationTime: Int
  id: Int!
  p256dh: String!
}

type Query {
  cockpitSession(id: ID!): Session
  feedbacks(id: ID!): [Feedback!]
  getCourseOverviewData(courseId: ID!): ParticipantLearningData
  learningElement(id: ID!): LearningElement
  microSession(id: ID!): MicroSession
  participations(endpoint: String): [Participation!]
  pinnedFeedbacks(id: ID!): Session
  runningSessions(shortname: String!): [Session!]
  self: Participant
  session(id: ID!): Session
  sessionEvaluation(id: ID!): SessionEvaluation
  sessionLeaderboard(sessionId: ID!): [LeaderboardEntry!]
  userProfile: User
  userSessions: [Session!]
}

interface QuestionData {
  content: String!
  contentPlain: String!
  id: Int!
  isArchived: Boolean!
  isDeleted: Boolean!
  name: String!
  type: String!
}

type QuestionFeedback {
  correct: Boolean!
  feedback: String!
  ix: Int!
  value: String!
}

type QuestionInstance {
  attachments: [Attachment]
  evaluation: InstanceEvaluation
  id: Int!
  questionData: QuestionData!
}

input ResponseInput {
  choices: [Int!]
  value: String
}

type Session {
  accessMode: AccessMode!
  activeBlock: SessionBlock
  blocks: [SessionBlock!]
  confusionFeedbacks: [AggregatedConfusionFeedbacks]
  course: Course
  createdAt: DateTime!
  displayName: String!
  feedbacks: [Feedback]
  finishedAt: DateTime
  id: ID!
  isAudienceInteractionActive: Boolean!
  isGamificationEnabled: Boolean!
  isModerationEnabled: Boolean!
  linkTo: String
  name: String!
  namespace: String!
  startedAt: DateTime
  status: SessionStatus!
}

type SessionBlock {
  execution: Int!
  expiresAt: DateTime
  id: Int!
  instances: [QuestionInstance!]!
  randomSelection: Boolean
  status: SessionBlockStatus!
  timeLimit: Int
}

enum SessionBlockStatus {
  ACTIVE
  EXECUTED
  SCHEDULED
}

type SessionEvaluation {
  id: ID!
  instanceResults: [InstanceResults!]
}

enum SessionStatus {
  COMPLETED
  PREPARED
  RUNNING
  SCHEDULED
}

type Subscription {
  feedbackAdded(sessionId: ID!): Feedback
  feedbackCreated(sessionId: ID!): Feedback
  feedbackRemoved(sessionId: ID!): Int
  feedbackUpdated(sessionId: ID!): Feedback
  runningSessionUpdated(sessionId: ID!): SessionBlock
}

input SubscriptionKeys {
  auth: String!
  p256dh: String!
}

input SubscriptionObjectInput {
  endpoint: String!
  expirationTime: Int
  keys: SubscriptionKeys!
}

type User {
  description: String
  email: String!
  id: ID!
  isActive: Boolean!
  shortname: String!
}