type Achievement {
  description: String!
  icon: String!
  iconColor: String
  id: Int!
  name: String!
}

type Attachment {
  description: String
  href: String!
  id: ID!
  name: String!
  originalName: String
  type: String!
}

type AttachmentInstance {
  description: String
  href: String!
  id: ID!
  name: String!
  originalName: String
  type: String!
}

input AvatarSettingsInput {
  accessory: String!
  clothing: String!
  clothingColor: String!
  eyes: String!
  facialHair: String!
  hair: String!
  hairColor: String!
  mouth: String!
  skinTone: String!
}

type AwardEntry {
  description: String!
  displayName: String!
  id: Int!
  name: String!
  order: Int!
  participant: Participant!
  participantGroup: ParticipantGroup!
  type: String!
}

input BlockInput {
  questionIds: [Int!]!
  randomSelection: Int
  timeLimit: Int
}

type Choice {
  correct: Boolean
  feedback: String
  ix: Int!
  value: String!
}

type ChoiceQuestionOptions {
  choices: [Choice!]!
}

type ChoicesQuestionData implements QuestionData {
  content: String!
  id: Int!
  name: String!
  options: ChoiceQuestionOptions!
  pointsMultiplier: Int!
  type: String!
}

type ClassAchievementInstance {
  id: Int!
}

type ConfusionTimestep {
  createdAt: Date!
  difficulty: Int!
  id: Int!
  numberOfParticipants: Int
  speed: Int!
}

type Course {
  averageActiveScore: Float
  averageScore: Float
  awards: [AwardEntry!]!
  color: String
  createdAt: Date!
  description: String
  displayName: String!
  id: ID!
  isArchived: Boolean
  leaderboard: [LeaderboardEntry!]!
  learningElements: [LearningElement!]!
  microSessions: [MicroSession!]!
  name: String!
  numOfActiveParticipants: Int
  numOfParticipants: Int
  pinCode: Int
  sessions: [Session!]!
  updatedAt: Date!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

type EvaluationBlock {
  blockIx: Int
  blockStatus: SessionBlockStatus!
  tabData: [TabData!]!
}

type Feedback {
  content: String!
  createdAt: Date!
  id: Int!
  isPinned: Boolean!
  isPublished: Boolean!
  isResolved: Boolean!
  resolvedAt: Date
  responses: [FeedbackResponse!]!
  votes: Int!
}

type FeedbackResponse {
  content: String!
  createdAt: Date!
  id: Int!
  negativeReactions: Int!
  positiveReactions: Int!
}

type FreeTextQuestionData implements QuestionData {
  content: String!
  id: Int!
  name: String!
  options: FreeTextQuestionOptions!
  pointsMultiplier: Int!
  type: String!
}

type FreeTextQuestionOptions {
  restrictions: FreeTextRestrictions!
  solutions: [String!]!
}

type FreeTextRestrictions {
  maxLength: Int
}

type GroupAchievementInstance {
  id: Int!
}

type GroupActivity {
  id: ID!
}

type GroupActivityClue {
  displayName: String!
  id: Int!
  name: String!
}

type GroupActivityClueAssignment {
  id: Int!
}

type GroupActivityClueInstance {
  displayName: String!
  id: Int!
  name: String!
  participant: Participant!
  type: ParameterType!
  unit: String
  value: String
}

input GroupActivityDecisionInput {
  id: Int!
  response: String
  selectedOptions: [Int!]!
}

type GroupActivityDetails {
  activityInstance: GroupActivityInstance
  clues: [GroupActivityClue!]!
  course: Course!
  description: String
  displayName: String!
  group: ParticipantGroup!
  id: String!
  instances: [QuestionInstance!]!
  name: String!
  scheduledEndAt: Date
  scheduledStartAt: Date
}

type GroupActivityInstance {
  clues: [GroupActivityClueInstance!]!
  decisions: Json
  decisionsSubmittedAt: Date
  id: Int!
}

type GroupActivityParameter {
  id: Int!
}

type GroupLeaderboardEntry {
  id: ID!
  isMember: Boolean
  name: String!
  rank: Int!
  score: Float!
}

type InstanceEvaluation {
  choices: Json!
  feedbacks: [QuestionFeedback!]
  newPointsFrom: Date
  percentile: Float
  pointsAwarded: Float
  score: Float!
}

type InstanceResult {
  blockIx: Int
  id: String!
  instanceIx: Int!
  participants: Int!
  questionData: QuestionData!
  results: Json!
  statistics: Statistics!
  status: SessionBlockStatus!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LeaderboardEntry {
  avatar: String!
  id: Int!
  isSelf: Boolean!
  lastBlockOrder: Int!
  participant: Participant!
  participantId: String!
  participation: Participation!
  rank: Int!
  score: Float!
  username: String!
}

type LeaderboardStatistics {
  averageScore: Float!
  participantCount: Int!
}

type LearningElement {
  course: Course!
  courseId: String!
  description: String
  displayName: String!
  id: String!
  instances: [QuestionInstance!]!
  name: String!
  numOfInstances: Int!
  orderType: LearningElementOrderType!
  pointsMultiplier: Int!
  previousPointsAwarded: Float!
  previousScore: Float!
  previouslyAnswered: Int!
  resetTimeDays: Int
  totalTrials: Int!
}

enum LearningElementOrderType {
  LAST_RESPONSE
  SEQUENTIAL
  SHUFFLED
}

type LeaveCourseParticipation {
  id: String!
  participation: Participation!
}

type MicroSession {
  course: Course!
  description: String
  displayName: String!
  id: ID!
  instances: [QuestionInstance!]!
  name: String!
  numOfInstances: Int
  pointsMultiplier: Float!
  scheduledEndAt: Date!
  scheduledStartAt: Date!
}

type Mutation {
  activateSessionBlock(sessionBlockId: Int!, sessionId: String!): Session
  addConfusionTimestep(difficulty: Int!, sessionId: String!, speed: Int!): ConfusionTimestep
  cancelSession(id: String!): Session
  changeCourseColor(color: String!, courseId: String!): Course
  changeCourseDescription(courseId: String!, input: String!): Course
  changeSessionSettings(id: String!, isConfusionFeedbackEnabled: Boolean, isGamificationEnabled: Boolean, isLiveQAEnabled: Boolean, isModerationEnabled: Boolean): Session
  createFeedback(content: String!, sessionId: String!): Feedback
  createLearningElement(courseId: String, description: String, displayName: String!, multiplier: Int!, name: String!, order: LearningElementOrderType!, questions: [Int!]!, resetTimeDays: Int!): LearningElement
  createMicroSession(courseId: String, description: String, displayName: String!, endDate: Date!, multiplier: Int!, name: String!, questions: [Int!]!, startDate: Date!): MicroSession
  createParticipantAndJoinCourse(courseId: String!, password: String!, pin: Int!, username: String!): Participant
  createParticipantGroup(courseId: String!, name: String!): ParticipantGroup
  createSession(blocks: [BlockInput!]!, courseId: String, description: String, displayName: String!, isGamificationEnabled: Boolean, multiplier: Int!, name: String!): Session
  deactivateSessionBlock(sessionBlockId: Int!, sessionId: String!): Session
  deleteFeedback(id: Int!): Feedback
  deleteFeedbackResponse(id: Int!): Feedback
  deleteQuestion(id: Int!): Question
  deleteTag(id: Int!): Tag
  editMicroSession(courseId: String, description: String, displayName: String!, endDate: Date!, id: String!, multiplier: Int!, name: String!, questions: [Int!]!, startDate: Date!): MicroSession
  editSession(blocks: [BlockInput!]!, courseId: String, description: String, displayName: String!, id: String!, isGamificationEnabled: Boolean, multiplier: Int!, name: String!): Session
  editTag(id: Int!, name: String!): Tag
  endSession(id: String!): Session
  generateLoginToken: User
  joinCourse(courseId: String!): ParticipantLearningData
  joinCourseWithPin(courseId: String!, pin: Int!): Participant
  joinParticipantGroup(code: Int!, courseId: String!): ParticipantGroup
  leaveCourse(courseId: String!): LeaveCourseParticipation
  leaveParticipantGroup(courseId: String!, groupId: String!): ParticipantGroup
  loginParticipant(password: String!, username: String!): ID
  loginUser(email: String!, password: String!): String
  loginUserToken(email: String!, token: String!): ID
  logoutParticipant: ID
  logoutUser: ID
  markMicroSessionCompleted(courseId: String!, id: String!): Participation
  pinFeedback(id: Int!, isPinned: Boolean!): Feedback
  publishFeedback(id: Int!, isPublished: Boolean!): Feedback
  registerParticipantFromLTI(courseId: String!, participantId: String!): ParticipantLearningData
  resolveFeedback(id: Int!, isResolved: Boolean!): Feedback
  respondToFeedback(id: Int!, responseContent: String!): Feedback
  startSession(id: String!): Session
  submitGroupActivityDecisions(activityInstanceId: Int!, decisions: [GroupActivityDecisionInput!]!): GroupActivityInstance
  subscribeToPush(courseId: String!, subscriptionObject: SubscriptionObjectInput!): Participation
  updateParticipantProfile(avatar: String, avatarSettings: AvatarSettingsInput, password: String, username: String): Participant
  upvoteFeedback(feedbackId: Int!, increment: Int!): Feedback
  voteFeedbackResponse(id: Int!, incrementDownvote: Int!, incrementUpvote: Int!): FeedbackResponse
}

type NumericalQuestionData implements QuestionData {
  content: String!
  id: Int!
  name: String!
  options: NumericalQuestionOptions!
  pointsMultiplier: Int!
  type: String!
}

type NumericalQuestionOptions {
  accuracy: Int
  placeholder: String
  restrictions: NumericalRestrictions!
  solutionRanges: [NumericalSolutionRange!]!
  unit: String
}

type NumericalRestrictions {
  max: Int
  min: Int
}

type NumericalSolutionRange {
  max: Int
  min: Int
}

enum ParameterType {
  NUMBER
  STRING
}

type Participant {
  achievements: [ParticipantAchievementInstance!]!
  avatar: String
  avatarSettings: Json!
  id: ID!
  isSelf: Boolean!
  lastLoginAt: Date
  level: Int!
  participantGroups: [ParticipantGroup!]!
  rank: Int!
  score: Float!
  username: String!
  xp: Int!
}

type ParticipantAchievementInstance {
  achievedAt: Date!
  achievedCount: Int!
  achievement: Achievement!
  id: Int!
}

type ParticipantGroup {
  averageMemberScore: Float!
  code: Int!
  groupActivityScore: Float!
  id: ID!
  name: String!
  participants: [Participant!]!
  score: Float!
}

type ParticipantLearningData {
  course: Course
  groupLeaderboard: [GroupLeaderboardEntry!]
  groupLeaderboardStatistics: LeaderboardStatistics
  id: String!
  leaderboard: [LeaderboardEntry!]
  leaderboardStatistics: LeaderboardStatistics
  participant: Participant
  participantToken: String
  participation: Participation
}

type Participation {
  completedMicroSessions: [String!]!
  course: Course!
  id: Int!
  isActive: Boolean!
  subscriptions: [PushSubscription!]!
}

type PushSubscription {
  endpoint: String!
  id: Int!
}

type Query {
  basicCourseInformation(courseId: String!): Course
  cockpitSession(id: String!): Session
  controlCourse(id: String!): Course
  controlCourses: [Course!]
  controlSession(id: String!): Session
  course(id: String!): Course
  feedbacks(id: String!): [Feedback!]
  getCourseOverviewData(courseId: String!): ParticipantLearningData
  getLoginToken: User
  groupActivityDetails(activityId: String!, groupId: String!): GroupActivityDetails
  learningElement(id: String!): LearningElement
  learningElements: [LearningElement!]
  liveSession(id: String!): Session
  microSession(id: String!): MicroSession
  participantGroups(courseId: String!): [ParticipantGroup!]
  participations(endpoint: String): [Participation!]
  pinnedFeedbacks(id: String!): Session
  question(id: Int!): Question
  runningSessions(shortname: String!): [Session!]
  self: Participant
  session(id: String!): Session
  sessionEvaluation(id: String!): SessionEvaluation
  sessionLeaderboard(sessionId: String!): [LeaderboardEntry!]
  singleMicroSession(id: String!): MicroSession
  unassignedSessions: [Session!]
  userCourses: [Course!]
  userProfile: User
  userQuestions: [Question!]
  userSessions: [Session!]
  userTags: [Tag!]
}

type Question {
  attachments: [Attachment!]!
  content: String!
  createdAt: Date!
  hasAnswerFeedbacks: Boolean!
  hasSampleSolution: Boolean!
  id: Int!
  isArchived: Boolean!
  isDeleted: Boolean!
  name: String!
  options: Json!
  pointsMultiplier: Int!
  questionData: QuestionData!
  tags: [Tag!]!
  type: String!
  updatedAt: Date!
}

interface QuestionData {
  content: String!
  id: Int!
  name: String!
  pointsMultiplier: Int!
  type: String!
}

type QuestionFeedback {
  correct: Boolean!
  feedback: String!
  ix: Int!
  value: String!
}

type QuestionInstance {
  attachments: [AttachmentInstance!]!
  evaluation: InstanceEvaluation
  id: Int!
  pointsMultiplier: Int!
  questionData: QuestionData!
}

type QuestionResponse {
  id: Int!
}

type QuestionResponseDetail {
  id: Int!
}

type Session {
  accessMode: SessionAccessMode!
  activeBlock: SessionBlock!
  blocks: [SessionBlock!]!
  confusionFeedbacks: [ConfusionTimestep!]!
  course: Course!
  createdAt: Date!
  description: String
  displayName: String!
  feedbacks: [Feedback!]!
  finishedAt: Date
  id: ID!
  isConfusionFeedbackEnabled: Boolean!
  isGamificationEnabled: Boolean!
  isLiveQAEnabled: Boolean!
  isModerationEnabled: Boolean!
  linkTo: String
  linkToJoin: String
  name: String!
  namespace: String!
  numOfBlocks: Int
  numOfQuestions: Int
  pinCode: Int
  pointsMultiplier: Int!
  startedAt: Date
  status: SessionStatus!
  updatedAt: Date
}

enum SessionAccessMode {
  PUBLIC
  RESTRICTED
}

type SessionBlock {
  execution: Int
  expiresAt: Date
  id: Int!
  instances: [QuestionInstance!]!
  order: Int
  randomSelection: Int
  status: SessionBlockStatus!
  timeLimit: Int
}

enum SessionBlockStatus {
  ACTIVE
  EXECUTED
  SCHEDULED
}

type SessionEvaluation {
  blocks: [EvaluationBlock!]!
  confusionFeedbacks: [ConfusionTimestep!]!
  feedbacks: [Feedback!]!
  id: String!
  instanceResults: [InstanceResult!]!
  isGamificationEnabled: Boolean!
  status: SessionStatus!
}

enum SessionStatus {
  COMPLETED
  PREPARED
  RUNNING
  SCHEDULED
}

type Statistics {
  max: Float!
  mean: Float!
  median: Float!
  min: Float!
  q1: Float!
  q3: Float!
  sd: Float!
}

input SubscriptionKeysInput {
  auth: String!
  p256dh: String!
}

input SubscriptionObjectInput {
  endpoint: String!
  expirationTime: Int
  keys: SubscriptionKeysInput!
}

type TabData {
  id: String!
  name: String!
  questionIx: Int
  status: String!
}

type Tag {
  id: Int!
  name: String!
}

type Title {
  id: Int!
}

type User {
  email: String!
  id: ID!
  isActive: Boolean!
  loginToken: String
  loginTokenExpiresAt: Date
  shortname: String!
}